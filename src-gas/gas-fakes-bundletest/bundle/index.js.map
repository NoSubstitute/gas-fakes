{
  "version": 3,
  "sources": ["<stdin>"],
  "sourcesContent": ["function main() {\n  driveFolders ()\n  driveFiles ()\n  driveSearch()\n  testItunesData()\n}\n\n\nfunction testItunesData () {\n  Logger.log(getItunesData('Thriller'));\n}\n/**\n* from the itunes sheet, get all the rows that are the given genre\n* and make an array of objects\n* @param {string} [genre] the genre to get or all if missing\n* @return {[object]} the data\n*/\nfunction getItunesData (genre) {\n\n  // use the sean connery spreadsheet\n  var SHEET_ID = '1JiDI-BN3cpjSyAvKPJ_7zRsrEbF0l02rUF6BisjLbqU';\n  var SHEET_NAME = \"sean connery\";\n  \n  return GasBegUtils.sheets.getAsObjects(SHEET_ID , SHEET_NAME)\n  .filter(function(d) {\n    return !genre || d.primaryGenreName === genre;\n  })\n  \n  \n}\n\n\n\n// get data from the Itunes spreadsheet, using code from previous lessons \n// you'll need - getItunesData\n// pick a random image from the artworkUrl100 column\n// tidy up using folder names below\n// create a folder using the TEMP_DRIVE_FOLDER constand\n// create a file using the TEMP_IMAGE_FILE constant\n// get the blob of the image - use GasBegUtils.fetch.getImageFromUrl\n// set its name\n// check whats on Drive\nvar TEMP_IMAGE_FILE = TEMP_DRIVE_FILE + '-image';\nfunction exerciseSolution() {\n  \n  var backoff = GasBegUtils.useful.expBackoff;\n\n  // clean up previous folders & files\n  GasBegUtils.drive.deleteFolders (TEMP_DRIVE_FOLDER);\n\n  // get data from Itunes sheet\n  var data = getItunesData();\n  \n  // pick a random row\n  var row = Math.round(Math.random() * (data.length-1));\n  \n  // get the image\n  var blob = GasBegUtils.fetch.getImageFromUrl(data[row].artworkUrl100);\n  \n  // set the name\n  blob.setName (TEMP_IMAGE_FILE);\n  \n  // create the folder\n  var folder = backoff (function () {\n    return DriveApp.createFolder(TEMP_DRIVE_FOLDER);\n  });\n  \n  // create the image file\n  var file = backoff (function () {\n    return folder.createFile(blob);\n  });\n  \n  // all done\n}\n\n\n\n/**\n* utilities to reuse\n* @namespace GasBegUtils\n*/\nvar GasBegUtils = (function (ns) {\n  \n  // utilities for drive\n  ns.drive = {\n    \n    deleteFiles : function (name) {\n      // we havent covered the Drive service yet, but we need it to remove files\n      // we'll cover it in a later chapter\n      var iter = DriveApp.getFilesByName(name);\n      while (iter.hasNext()) {\n        iter.next().setTrashed(true);\n      }\n    },\n    \n    deleteFolders : function (name) {\n      // we havent covered the Drive service yet, but we need it to remove files\n      // we'll cover it in a later chapter\n      var iter = DriveApp.getFoldersByName(name);\n      while (iter.hasNext()) {\n        iter.next().setTrashed(true);\n      }\n    },\n    \n    getBlob : function (id) {\n      return DriveApp.getFileById(id).getBlob();\n    }\n    \n  };\n  \n  // utilites for urlfetchapp\n  ns.fetch = {\n    getImageFromUrl: function (url) {\n      return UrlFetchApp.fetch(url).getBlob();\n    }\n  };\n  \n  // utilities for properties\n  ns.properties = {\n  \n    setScript : function (key , value) {\n      var store = PropertiesService.getScriptProperties();\n      store.setProperty(key, JSON.stringify(value));\n    },\n    \n    getScript : function (key) {\n      var store = PropertiesService.getScriptProperties();\n      var value = store.getProperty(key);\n      return value ? JSON.parse(value) : null;\n    }\n    \n    \n  }\n  \n  // utilities for sheets\n  ns.sheets = {\n    \n    /**\n    * get the sheet as an array of objects using the header row as property names\n    * @param {string} sheetId the id\n    * @param {string} sheetName the sheet name\n    * @return {[object]} the result\n    */\n    getAsObjects: function (sheetId , sheetName) {\n      \n      // get the values\n      var sheet = SpreadsheetApp.openById(sheetId).getSheetByName(sheetName);\n      var values = sheet.getDataRange().getValues();\n      \n      // pull out the headers\n      var heads = values.shift();\n      \n      // reduce to a an object per row\n      return values.map (function (row) {\n        return row.reduce (function (p,c) {\n          p[heads[Object.keys(p).length]] = c;\n          return p;\n        },{})\n      });\n      \n    }\n  };\n  \n  // various useful utilities\n  ns.useful = {\n    \n    \n    /**\n    * recursive rateLimitExpBackoff()\n    * @param {function} callBack some function to call that might return rate limit exception\n    * @param {object} options properties as below\n    * @param {number} [attempts=1] optional the attempt number of this instance - usually only used recursively and not user supplied\n    * @param {number} [options.sleepFor=750] optional amount of time to sleep for on the first failure in missliseconds\n    * @param {number} [options.maxAttempts=5] optional maximum number of amounts to try\n    * @param {boolean} [options.logAttempts=true] log re-attempts to Logger\n    * @param {function} [options.checker] function to check whether error is retryable\n    * @param {function} [options.lookahead] function to check response and force retry (passes response,attemprs)\n    * @return {*} results of the callback \n    */\n    expBackoff: function ( callBack,options,attempts) {\n      \n      //sleepFor = Math.abs(options.sleepFor ||\n      \n      options = options || {};\n      let optionsDefault = { \n        sleepFor:  750,\n        maxAttempts:5,                  \n        checker:errorQualifies,\n        logAttempts:true\n      }\n      \n      // mixin\n      Object.keys(optionsDefault).forEach(function(k) {\n        if (!options.hasOwnProperty(k)) {\n          options[k] = optionsDefault[k];\n        }\n      });\n      \n      \n      // for recursion\n      attempts = attempts || 1;\n      \n      // make sure that the checker is really a function\n      if (typeof(options.checker) !== \"function\") {\n        throw ns.useful.errorStack(\"if you specify a checker it must be a function\");\n      }\n      \n      // check properly constructed\n      if (!callBack || typeof(callBack) !== \"function\") {\n        throw ns.useful.errorStack(\"you need to specify a function for rateLimitBackoff to execute\");\n      }\n      \n      function waitABit (theErr) {\n        \n        //give up?\n        if (attempts > options.maxAttempts) {\n          throw ns.useful.errorStack(theErr + \" (tried backing off \" + (attempts-1) + \" times\");\n        }\n        else {\n          // wait for some amount of time based on how many times we've tried plus a small random bit to avoid races\n          Utilities.sleep (\n            Math.pow(2,attempts)*options.sleepFor + \n            Math.round(Math.random() * options.sleepFor)\n          );\n          \n        }\n      }\n      \n      // try to execute it\n      try {\n        var response = callBack(options, attempts);\n        \n        // maybe not throw an error but is problem nevertheless\n        if (options.lookahead && options.lookahead(response,attempts)) {\n          if(options.logAttempts) { \n            Logger.log(\"backoff lookahead:\" + attempts);\n          }\n          waitABit('lookahead:');\n          return ns.useful.expBackoff ( callBack, options, attempts+1) ;\n          \n        }\n        return response;\n      }\n      \n      // there was an error\n      catch(err) {\n        \n        if(options.logAttempts) { \n          Logger.log(\"backoff \" + attempts + \":\" +err);\n        }\n        \n        // failed due to rate limiting?\n        if (options.checker(err)) {\n          waitABit(err);\n          return ns.useful.expBackoff ( callBack, options, attempts+1) ;\n        }\n        else {\n          // some other error\n          throw ns.useful.errorStack(err);\n        }\n      }\n      \n      function errorQualifies (errorText) {\n        \n        return [\"Exception: Service invoked too many times\",\n                \"Exception: Rate Limit Exceeded\",\n                \"Exception: Quota Error: User Rate Limit Exceeded\",\n                \"Service error:\",\n                \"Exception: Service error:\", \n                \"Exception: User rate limit exceeded\",\n                \"Exception: Internal error. Please try again.\",\n                \"Exception: Cannot execute AddColumn because another task\",\n                \"Service invoked too many times in a short time:\",\n                \"Exception: Internal error.\",\n                \"User Rate Limit Exceeded\",\n                \"Exception: \u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D \u043B\u0438\u043C\u0438\u0442: DriveApp.\",\n                \"Exception: Address unavailable\"\n               ]\n        .some(function(e){\n          return  errorText.toString().slice(0,e.length) == e  ;\n        }) ;\n        \n      }\n    },\n    \n    /**\n    * get the stack\n    * @param {Error} e the error\n    * @return {string} the stack trace\n    */\n    errorStack : function  (e) {\n      try {\n        // throw a fake error\n        throw new Error();  //x is undefined and will fail under use struct- ths will provoke an error so i can get the call stack\n      }\n      catch(err) {\n        return 'Error:' + e + '\\n' + err.stack.split('\\n').slice(1).join('\\n');\n      }\n    }\n  };\n  \n  return ns;\n  \n})(GasBegUtils || {});\n\n\n\n\n\n\n// more info on search parameters\n// https://developers.google.com/drive/v3/web/search-parameters\nfunction driveSearch() {\n  \n  var backoff = GasBegUtils.useful.expBackoff;\n\n  // add a new folder\n  var folder = backoff(function () {\n    return DriveApp.createFolder(TEMP_DRIVE_FOLDER);\n  });\n  \n  // add a new file \n  var file = folder.createFile(TEMP_DRIVE_FILE, 'here is some text data',MimeType.PDF);\n\n  // search files\n  var fileIterator = DriveApp.searchFiles(\n    \"title contains '----temp-file-can-be-deleted' and mimeType contains 'pdf'\");\n\n  while (fileIterator.hasNext()) {\n    Logger.log(fileIterator.next().getName());\n  }\n}\n\n\nvar TEMP_DRIVE_FOLDER = \"----temp-folder-can-be-deleted\";\nvar TEMP_DRIVE_FOLDER_SUB = TEMP_DRIVE_FOLDER + 'sub';\n\nfunction driveFolders() {\n  \n\n  // get all the folders on my drive\n  var folderIterator = DriveApp.getFolders();\n\n  // loop through them\n  var count = 0;\n  while (folderIterator.hasNext() && count < 20) {\n    count ++;\n    folderIterator.next();\n  }\n\n  // how many are there\n  Logger.log('at least ' + count + ' folders');\n\n  // add a new folder\n  var folder = DriveApp.createFolder(TEMP_DRIVE_FOLDER);\n  \n  // get the folder\n  Logger.log(folder.getName());\n  Logger.log(folder.getId());\n  \n\n  // create a folder in a folder\n  var sub = folder.createFolder(TEMP_DRIVE_FOLDER_SUB);\n  \n  // get the folder\n  Logger.log(sub.getName());\n  Logger.log(sub.getId());\n  \n  // create another\n  folder.createFolder(TEMP_DRIVE_FOLDER_SUB);\n    \n  \n}\n\n\nvar TEMP_DRIVE_FILE = \"----temp-file-can-be-deleted\";\n\nfunction driveFiles() {\n  \n  var backoff = GasBegUtils.useful.expBackoff;\n\n  // get all the files on my drive\n  var fileIterator = DriveApp.getFiles();\n\n  // loop through them\n  var count = 0;\n  // there are too many so just count the first 50\n  while (fileIterator.hasNext() && count < 50) {\n    count ++;\n    fileIterator.next();\n  }\n\n  // how many are there\n  Logger.log('at least ' + count + ' files');\n  \n\n  // add a new folder\n  var folder = DriveApp.createFolder(TEMP_DRIVE_FOLDER);\n  \n\n  // add a new file with no mimetype\n  var file = folder.createFile(TEMP_DRIVE_FILE, 'here is some text data');\n  \n\n  // get the file\n  Logger.log(file.getName());\n  Logger.log(file.getId());\n  Logger.log(file.getMimeType());\n  \n\n  // now create one with a specific mimetype\n  var file = folder.createFile(TEMP_DRIVE_FILE,'here is some text data',MimeType.PDF);\n  Logger.log(file.getMimeType());\n  \n\n  // getting a file returns a blob\n  var blob = file.getBlob();\n  Logger.log(blob.getContentType());\n  Logger.log(blob.getDataAsString());\n  \n\n  // blobs can be written to a file\n  var file = folder.createFile(blob);\n  \n\n  // the first parent\n  Logger.log(file.getParents().next().getName());\n  // the first child\n  Logger.log(file.getParents().next().getFiles().next().getName());\n  \n\n  // we should really be using backoff\n  var fileIterator = backoff(function () {\n    return folder.getFiles();\n  });\n  \n\n  \n}\n"],
  "mappings": "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",
  "names": []
}
